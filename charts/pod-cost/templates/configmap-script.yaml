---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "pod-cost.fullname" . }}-script
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "pod-cost.labels" . | nindent 4 }}
data:
  agent.py: |
    import os
    import time
    import requests
    import logging
    from datetime import datetime, timezone
    from kubernetes import client, config

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    # Load Kubernetes config
    config.load_incluster_config()

    # Initialize clients
    v1 = client.CoreV1Api()
    metrics_client = client.CustomObjectsApi()

    # Configuration
    API_ENDPOINT = os.getenv("API_ENDPOINT")
    COLLECTION_INTERVAL = int(os.getenv("COLLECTION_INTERVAL", "60"))
    CLUSTER_NAME = os.getenv("CLUSTER_NAME", "unknown-cluster")
    CUSTOMER_ID = os.getenv("CUSTOMER_ID")

    def get_node_metrics():
        """Collect node-level metrics including health data"""
        try:
            nodes = v1.list_node()
            node_metrics = metrics_client.list_cluster_custom_object(
                "metrics.k8s.io", "v1beta1", "nodes"
            )

            metrics = []
            for node in nodes.items:
                node_name = node.metadata.name

                # Find corresponding metrics
                node_metric = next(
                    (m for m in node_metrics["items"] if m["metadata"]["name"] == node_name),
                    None
                )

                # Extract node conditions
                conditions = []
                if node.status.conditions:
                    for condition in node.status.conditions:
                        conditions.append({
                            "type": condition.type,
                            "status": condition.status,
                            "reason": condition.reason or "",
                            "message": condition.message or ""
                        })

                if node_metric:
                    metrics.append({
                        "node_name": node_name,
                        "cpu_usage": node_metric["usage"]["cpu"],
                        "memory_usage": node_metric["usage"]["memory"],
                        "capacity_cpu": node.status.capacity.get("cpu", "0"),
                        "capacity_memory": node.status.capacity.get("memory", "0"),
                        "allocatable_cpu": node.status.allocatable.get("cpu", "0"),
                        "allocatable_memory": node.status.allocatable.get("memory", "0"),
                        "conditions": conditions,
                        "unschedulable": node.spec.unschedulable or False,
                    })

            return metrics
        except Exception as e:
            logger.error(f"Error getting node metrics: {e}")
            return []

    def get_container_state(container_status):
        """Extract container state from container status"""
        if container_status.state:
            if container_status.state.running:
                return "running"
            elif container_status.state.waiting:
                reason = container_status.state.waiting.reason or "waiting"
                return reason  # e.g., "CrashLoopBackOff", "ImagePullBackOff"
            elif container_status.state.terminated:
                return "terminated"
        return "unknown"

    def get_pod_status(pod):
        """Determine overall pod status including container states"""
        phase = pod.status.phase or "Unknown"

        # Check container statuses for more specific status
        if pod.status.container_statuses:
            for cs in pod.status.container_statuses:
                if cs.state and cs.state.waiting:
                    reason = cs.state.waiting.reason
                    if reason in ["CrashLoopBackOff", "ImagePullBackOff", "ErrImagePull", "CreateContainerConfigError"]:
                        return reason

        return phase

    def get_pod_metrics():
        """Collect pod-level metrics including health data"""
        try:
            pods = v1.list_pod_for_all_namespaces()
            pod_metrics = metrics_client.list_cluster_custom_object(
                "metrics.k8s.io", "v1beta1", "pods"
            )

            metrics = []
            for pod in pods.items:
                pod_name = pod.metadata.name
                namespace = pod.metadata.namespace

                # Find corresponding metrics
                pod_metric = next(
                    (m for m in pod_metrics["items"]
                     if m["metadata"]["name"] == pod_name and m["metadata"]["namespace"] == namespace),
                    None
                )

                # Calculate total restart count
                total_restarts = 0
                if pod.status.container_statuses:
                    for cs in pod.status.container_statuses:
                        total_restarts += cs.restart_count or 0

                # Extract pod conditions
                conditions = []
                if pod.status.conditions:
                    for condition in pod.status.conditions:
                        conditions.append({
                            "type": condition.type,
                            "status": condition.status,
                            "reason": condition.reason or "",
                            "message": condition.message or ""
                        })

                # Build container metrics with health data
                container_metrics = []
                container_statuses = {cs.name: cs for cs in (pod.status.container_statuses or [])}

                if pod_metric:
                    for container in pod_metric.get("containers", []):
                        container_name = container["name"]
                        cs = container_statuses.get(container_name)

                        container_metrics.append({
                            "name": container_name,
                            "cpu_usage": container["usage"]["cpu"],
                            "memory_usage": container["usage"]["memory"],
                            "state": get_container_state(cs) if cs else "unknown",
                            "restart_count": cs.restart_count if cs else 0,
                            "ready": cs.ready if cs else False
                        })
                else:
                    # No metrics available, but still include container health data
                    for cs in (pod.status.container_statuses or []):
                        container_metrics.append({
                            "name": cs.name,
                            "cpu_usage": "0",
                            "memory_usage": "0",
                            "state": get_container_state(cs),
                            "restart_count": cs.restart_count or 0,
                            "ready": cs.ready or False
                        })

                # Include all pods, not just running ones (for health tracking)
                metrics.append({
                    "pod_name": pod_name,
                    "namespace": namespace,
                    "node_name": pod.spec.node_name or "",
                    "status": get_pod_status(pod),
                    "phase": pod.status.phase or "Unknown",
                    "restart_count": total_restarts,
                    "conditions": conditions,
                    "containers": container_metrics,
                    "labels": pod.metadata.labels or {}
                })

            return metrics
        except Exception as e:
            logger.error(f"Error getting pod metrics: {e}")
            return []

    def send_metrics_to_api(node_metrics, pod_metrics):
        """Send collected metrics to the API"""
        payload = {
            "customer_id": CUSTOMER_ID,
            "cluster_name": CLUSTER_NAME,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "node_metrics": node_metrics,
            "pod_metrics": pod_metrics
        }

        headers = {
            "Content-Type": "application/json"
        }

        try:
            response = requests.post(
                API_ENDPOINT,
                json=payload,
                headers=headers,
                timeout=30
            )
            response.raise_for_status()
            logger.info(f"Successfully sent metrics to API. Status: {response.status_code}")
            return True
        except requests.exceptions.RequestException as e:
            logger.error(f"Error sending metrics to API: {e}")
            return False

    def main():
        logger.info(f"Starting metrics agent for customer: {CUSTOMER_ID}, cluster: {CLUSTER_NAME}")
        logger.info(f"Collection interval: {COLLECTION_INTERVAL} seconds")

        while True:
            try:
                logger.info("Collecting metrics...")

                node_metrics = get_node_metrics()
                pod_metrics = get_pod_metrics()

                logger.info(f"Collected metrics for {len(node_metrics)} nodes and {len(pod_metrics)} pods")

                if node_metrics or pod_metrics:
                    send_metrics_to_api(node_metrics, pod_metrics)
                else:
                    logger.warning("No metrics collected")

            except Exception as e:
                logger.error(f"Error in main loop: {e}")

            time.sleep(COLLECTION_INTERVAL)

    if __name__ == "__main__":
        main()
